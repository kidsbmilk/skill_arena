1、将CPU让给另一个线程
当线程放弃某个稀有的资源（如数据库连接或网络端口）时，它可能调用yield()函数临时降低自己的优先级，以便某个其他线程能够运行。

2、守护线程
有两类线程：用户线程和守护线程。用户线程是那些完成有用工作的线程。守护线程是那些仅提供辅助功能的线程。Thread类提供了setDaemon()函数。
Java程序将运行到所有用户线程终止，然后它将破坏所有的守护线程。在Java虚拟机（JVM）中，即使在main结束后，如果另一个用户线程仍在运行，
则程序仍然可以继续运行。

3、活锁
当一个线程忙于接受新任务以致它永远没有机会完成任何任务时，就会发生活锁。这个线程最终将超出缓冲区并导致程序崩溃。试想一个秘书需要录入一封信，
但她一直在忙于接电话，所以这封信永远不会被录入。

4、内存损坏
如果明智地使用synchronized关键字，则完全可以避免内存错误这种气人的问题。

5、资源耗尽
某些系统资源是有限的，如文件描述符。多线程程序可能耗尽资源，因为每个线程都可能希望有一个这样的资源。如果线程数相当大，或者某个资源的侯选线程数
远远超过了可用的资源数，则最好使用资源池。一个最好的示例是数据库连接池。只要线程需要使用一个数据库连接，它就从池中取出一个，使用以后再将它返回池中。
资源池也称为资源库。

6、调试大量的线程
有时一个程序因为有大量的线程在运行而极难调试。在这种情况下，下面的类可能会派上用场：

public class Prob extends Thread {
    public Probe() {}
    public void run() {
        while(true) {
            Thread[] x = new Thread[100];
            Thread.enumerate(x);
            for(int i=0; i<100; i++) {
                Thread t = x[i];
                if(t == null) {
                    break;
                }
                else {
                    System.out.println(t.getName() + "\t" + t.getPriority() + "\t" + t.isAlive() + "\t" + t.isDaemon());
                }
            }
        }
    }
}

7、限制线程优先级和调度
Java 线程模型涉及可以动态更改的线程优先级。本质上，线程的优先级是从 1 到 10 之间的一个数字，数字越大表明任务越紧急。
JVM 标准首先调用优先级较高的线程，然后才调用优先级较低的线程。但是，该标准对具有相同优先级的线程的处理是随机的。
如何处理这些线程取决于基层的操作系统策略。在某些情况下，优先级相同的线程分时运行；在另一些情况下，线程将一直运行到结束。
请记住，Java 支持 10 个优先级，基层操作系统支持的优先级可能要少得多，这样会造成一些混乱。因此，只能将优先级作为一种很粗略的工具使用。
最后的控制可以通过明智地使用 yield() 函数来完成。通常情况下，请不要依靠线程优先级来控制线程的状态。